------- FILE justinScroll.s LEVEL 1 PASS 2
      1  1527 ????						;/*
      2  1527 ????						;    Processor Information
      3  1527 ????						;*/
      4  1527 ????				      processor	6502	; This informs the assembler that we are using a 6502 processor.
      5  1527 ????
      6  1527 ????						;/*
      7  1527 ????						;    Memory Map
      8  1527 ????						;*/
      9  1001					      org	$1001	; mem location of user region
     10  1001		       0b 10		      dc.w	stubend
     11  1003		       01 00		      dc.w	1	; arbitrary line number for BASIC syntax
     12  1005		       9e 34 33 35*	      dc.b	$9e, "4353", 0	; allocate bytes. 4353 = 1101
     13  100b
     14  100b							;/*
     15  100b							;    Global Definitions
     16  100b							;*/
     17  100b		       ff d2	   CHROUT     =	$ffd2	; kernal character output routine
     18  100b
     19  100b							;/*
     20  100b							;    Utility Routines
     21  100b							;*/
     22  100b				   stubend
     23  100b		       00 00		      dc.w	0	; insert null byte
     24  100d
     25  100d							;/*
     26  100d							;    Data
     27  100d							;*/
     28  100d		       00 00 00    pad	      .byte.b	$00, $00, $00	; Padding so that next byte is on 8 byte boundary
     29  1010		       00 3c 26 56*chr_1      .byte.b	$00, $3c, $26, $56, $56, $26, $3c, $24	; sus?
     30  1018		       00 00 00 00*chr_1_b    .byte.b	$00, $00, $00, $00, $00, $00, $00, $00	; sus_v2?
     31  1020
     32  1020							;/*
     33  1020							;    Main Routine
     34  1020							;*/
     35  1101					      org	$1101	; mem location of code region
     36  1101				   start
     37  1101		       a9 fc		      lda	#$fc
     38  1103		       8d 05 90 	      sta	$9005	; load custom character set
     39  1106		       20 5f e5 	      jsr	$e55f	; clear screen
     40  1109		       a9 42		      lda	#$42	; set a to first character in new character set
     41  110b		       20 d2 ff 	      jsr	CHROUT
     42  110e		       a9 43		      lda	#$43	; set a to second character in new character set
     43  1110		       20 d2 ff 	      jsr	CHROUT
     44  1113
     45  1113				   loop
     46  1113		       a9 4f		      lda	#$4f
     47  1115		       8d 01 10 	      sta	$1001
     48  1118		       20 1c 15 	      jsr	timer
     49  111b
     50  111b		       a9 10		      lda	#$10
     51  111d		       8d 14 15 	      sta	$1514
     52  1120		       a9 10		      lda	#$10
     53  1122		       8d 13 15 	      sta	$1513
     54  1125
     55  1125		       20 01 15 	      jsr	charShift_R
     56  1128		       4c 13 11 	      jmp	loop
     57  112b
     58  112b
     59  112b							;/*
     60  112b							;    A.M.O.G.U.S. Character Right Shift Routine (Advanced Movement Of Graphics Using Shift)
     61  112b							;    @ Author: Justin Parker
     62  112b							;
     63  112b							;    @ Usage: Set $1501+13, $1501+12 to the low and high address bytes of the character to be shifted respectively
     64  112b							;    @ Location specific: Yes
     65  112b							;
     66  112b							;    # Notes: Requires linked characters to be stored at $***0 and $***8 respectively
     67  112b							;*/
     68  1501					      org	$1501	; mem location of new code region
     69  1501				   charShift_R
     70  1501		       ad 14 15 	      lda	$1514	; Get the high address byte
     71  1504		       8d 17 15 	      sta	$1517	; Store in the second ROR address byte
     72  1507		       ad 13 15 	      lda	$1513	; Get the low address byte
     73  150a		       09 08		      ora	#$08	; Add 8 to the low address byte (Since the linked character is stored at $***0)
     74  150c		       8d 16 15 	      sta	$1516	; Store in the first ROR address byte
     75  150f
     76  150f		       a2 07		      ldx	#$07	; Set x to 7 (The number of bytes needed to ROR)
     77  1511		       18		      clc		; Clear the carry flag
     78  1512				   csr_loop
     79  1512		       7e fe ff 	      ror	$fffe,x	; ff,fe == 1514,1513
     80  1515		       7e fe ff 	      ror	$fffe,x	; ff,fe == 1517,1516
     81  1518		       ca		      dex		; Decrement x
     82  1519		       d0 f7		      bne	csr_loop	; Branch if x got underflowed
     83  151b		       60		      rts
     84  151c
     85  151c							;/*
     86  151c							;    The best goddamn timer that's ever existed on pure American hardware god damnit
     87  151c							;    @ Author: Justin Parker
     88  151c							;
     89  151c							;    @ Usage: Set $1001 to the number of ~2ms intervals you want to wait for.
     90  151c							;    @ Location specific: No
     91  151c							;
     92  151c							;    # Notes: This is a blocking timer. It will not return until the timer has expired.
     93  151c							;*/
     94  151c				   timer
     95  151c		       ce 02 10 	      dec	$1002	; Decrement the timer low-bit (is not initially set, so timing may vary by up to 1 cycle)
     96  151f		       d0 fb		      bne	timer	; If the low-bit hasn't been underflowed, keep decrementing the low-bit
     97  1521		       ce 01 10 	      dec	$1001	; If the low-bit has been underflowed, decrement the timer high-bit
     98  1524		       d0 f6		      bne	timer	; If the high-bit hasn't been underflowed, keep decrementing the low-bit
     99  1526		       60		      rts		; If the high-bit has been underflowed, return from subroutine
    100  1527
